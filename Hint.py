# ССПИСКИ
# list()

"""Можно записывать и таким и таким образом"""
# a = list()
# a = []

'''Метод добавляет второй список к первому добавляемый список указываеться как аргумент. При этом второй список
остаеться прежним видоизменяеться только список к которому был добавлен другой список'''

## .extend()
# a = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
# b = [10, 11, 12]
# a.extend(b)
# print(a)


'''Метод добавляет один элемент в конец списка'''

## .append()
# a = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
# a.append(10)
# print(a)

'''Метод вставляет один элемент внутрь списка по индексу'''

## .insert()
# a = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
# a.insert(3, 10)
# print(a)


'''Метод возвращает элемент из списка по индексу и удаляет этот элемент из списка. Если не указать индекс, 
удалиться последний элемент списка'''

## .pop()
# a = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
# a.pop()
# print(a)


'''Метод удаляет указанный элемент из списка. Удаляет первый встретившийся элемент слава на право.'''

## .remove()
# a = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
# a.remove(2)
# print(a)


'''Метод считает колличество вхождений указанного элемента (тоесть сколько раз этот элемент встречаеться в списке)'''

## .count()
# a = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
# a.count(2)
# print(a)


'''Метод очищает список'''

## .clear()
# a = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
# a.clear()
# print(a)


'''Метод копирует список (при этом список копия не ссылаеться на оригинальный список)'''

## .copy()
# a = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
# a.copy()
# print(a)


'''Метод розварачивает список'''
## .reverse
# a = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
# a.reverse()
# print(a)

'''Сортирует список по порядку возростания также если список был развернут ранее то этот метод его развернет и 
отсортирует также принимает флаг reverse = True в этом случае разворачивает список и сортирует по ниспаданию'''

## .sort
# a = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
# a.sort()
# print(a)


'''Функции min и max принимают аргументом список и выводят максимальное или минимальное значение в эти функции также 
можно передать функции в качестве ключа'''

## max() min()
# a = [0, 4, -5, 6, 8, -11]
# print(min(a))
# print(max(a, key=abs))


# КОРТЕЖИ
# tuple()


'''Не изменяемый тип данных по этому при изменении tuple их нужно перезаписывать с ним не работают методы 
розширения списка типа .append()'''

"""Можно записывать и таким и таким образом"""

# tpl = tuple()
# tpl = ()


# count()
# tpl = (0, 1, 2, 3, 4, 5, 6, 7, 8, 9)
# print(tpl.count(1))

# index()
# tpl = (0, 1, 2, 3, 4, 5, 6, 7, 8, 9)
# print(tpl.index(4))

# max() min()
# a = (0, 4, -5, 6, 8, -11)
# print(min(a))
# print(max(a, key=abs))


# МНОЖЕСТВО
# set()

'''Варианты записи'''

# a = set([1, 2, 3, 4])
# print(a)
#
# a = {1, 2, 3, 4} # Важно если создать пустые фигурные скобки {} это будет не set а словарь при создании set важно
# print(a)         # заполнить фигурные скобки какими-то элементами через запятую например {1, 2, 'test'}
#
# a = set({1, 2, 3, 4})
# print(a)

'''set это неупорядоченная последовательность уникальных элементов это изменяемый тип данных'''

# a = {1, 2, 3, 4, 5, 5, 5, 5, 5, 5, 5, 'test', 'test', None, None}
# print(a)


'''Можно узнать длинну set'''

# a = {1, 2, 3, 4, 5, 5, 5, 5, 5, 5, 5, 'test', 'test', None, None}
# print(len(a))


'''Можно узнать наличие элемента в сете in'''

# a = {1, 2, 3, 4, 5, 5, 5, 5, 5, 5, 5, 'test', 'test', None, None}
# print('test' in a)


'''Можно сравнивать сеты между собой'''
# a = {1, 2, 3, 4, 5, 5, 5, 5, 5, 5, 5, 'test', 'test', None, None}
# b = {1, 2, 3, 4, 5, 5, 5, 5, 5, 5, 5, 'test', 'test', None, None}
# print(a == b)
# print(a is b) # Вернет False так как это два разных объекта которые равны по значению


'''Метод добавляет элемент в set'''

# add()
# a = {1, 2, 3, 4, 5, 'test', None}
# a.add('reTest') # Если добавлять значение которое уже есть в set оно добавлено не будет така как set это набор
# print(a)        # уникальных значений


# pop()
# a = {1, 2, 3, 4, 5, 'test', None}
# a.pop()
# print(a) # Возвращает какой-то элемент также в сете pop() не принимает аргументы


'''Метод удаляет элемент из сета но если элемента который указан как аргумент в remove() нет в сете будет ошибка'''

# remove()
# a = {1, 2, 3, 4, 5, 'test', None}
# a.remove(1)
# print(a)


'''Метод удаляет элемент из сета но если элемента который указан как аргумент в discard() нет в сете то ошибки не 
будет тоесть этот метод лучше использовать если мы не уверены в наличии элемента в сете но если элемент который 
указан как аргумент в discard() есть он будет удален'''

# discard()
# a = {1, 2, 3, 4, 5, 'test', None}
# a.discard(1)
# print(a)


'''Метод позволяющий объеденить множества при объединении в исходном множестве будут только уникальные элементы'''

# union()
# a = {1, 2, 3, 4, 5, 'test', None}
# b = {1, 2, 7, 9, 10, 'test', 'step', None}
# c = a.union(b)
# print(c)


'''Метод пересечения при объеденении множеств в исходном множестве будут только элементы которые есть и в первом и во 
втором множестве этот метод не перезаписывает изначальные саты а создает новый'''

# # intersection()
# a = {1, 2, 3, 4, 5, 'test', None}
# b = {1, 2, 7, 9, 10, 'test', 'step', None}
# c = a.intersection(b)
# print(c)


'''Тоже что и просто intersection() но этот метод записываеться к первому или второму сету. Отдельная переменная как 
в первом случае не создаеться и также этот метод перезаписывает сет у которого был вызван'''

# intersection_update()
# a = {1, 2, 3, 4, 5, 'test', None}
# b = {1, 2, 7, 9, 10, 'test', 'step', None}
# a.intersection_update(b)
# print(a)


'''Метод выводит разность сетов (тоесть те элементы которые не повторяются)'''

# difference()
# a = {1, 2, 3, 4, 5, 'test', None}
# b = {1, 2, 7, 9, 10, 'test', 'step', None}
# c = a.difference(b)
# print(c)


'''Принцып работы тот же что и у intersection_update() только выводим разность'''

# difference_update()
# a = {1, 2, 3, 4, 5, 'test', None}
# b = {1, 2, 7, 9, 10, 'test', 'step', None}
# a.difference_update(b)
# print(a)


'''Метод отображает являеться ли одно множество подмножеством другого, так как в сете а есть такиеже значения как и в 
сете b это "1, 2, 'test' " то данный метод выведет True'''

# issubset()
# a = {1, 2, 'test'}
# b = {1, 2, 7, 9, 10, 'test', 'step', None}
# c = a.issubset(b)
# print(c)


'''Метод очищает set'''

# clear()
# a = {1, 2, 7, 9, 10, 'test', 'step', None}
# a.clear()
# print(a)


'''Метод работает также как и в списке'''

# copy()
# a = {1, 2, 7, 9, 10, 'test', 'step', None}
# b = a.copy()
# print(b)


'''Метод работает также как и в списке'''

# max() min()
# a = {0, 4, -5, 6, 8, -11}
# print(min(a))
# print(max(a, key=abs))


'''Пример, чтобы сделать массив элементов уникальным (тоесть убрать все повторяющиеся элементы) нужно изменить тип 
данных на множество и потом снова вернуть в масив'''

# a = [1, 2, 3, 4, 5, 5, 5, 5, 5, 5, 5, 'test', 'test', None, None]
# b = list(set(a))
# print(b)


# МНОЖЕСТВО
# frozenset()

'''С frozenset можно делать все тоже самое что и с set но это не изменяемый тип данных по аналогии с list и tuple. 
list изменяемый tuple не изменяемый тип данных'''

# СЛОВАРЬ
# dict()

"""Варианты создания"""

'''При создании словаря фигурные скобки могут быть пустыми дальше там будет введены 'key': 'value' разделенные 
запятой. Это изменяемый тип данных'''
# a = dict()
# a = {}


# Пример

# a = dict(
#     name='Viktor',
#     age=29,
#     is_married=True,
#     pets_name=['Rex', 'Bob', 'Skub']
# )
#
# b = {
#     'name': 'Viktor',
#     'age': 29,
#     'is_married': True,
#     'pets_name': ['Rex', 'Bob', 'Skub'],
# }
#
# b['age'] = 30
# b['is_new'] = False
# b.pop('is_new') # Удаляет элемент из словаря при обращении по ключу
# print(a)


'''Метод позволяет получить значение из словаря также этот метод можно использовать в случае когда мы не уверены что 
это значение есть в словаре. Если значение есть то мы его получим если значения нет то получим None или получим 
значение которое мы указали вторым элементом'''

# get()
# a = dict(
#     name='Viktor',
#     age=29,
#     is_married=True,
#     pets_name=['Rex', 'Bob', 'Skub']
# )
# print(a.get('test'))
# print(a.get('test', 1))
# print(a.get('name'))


'''Можно искать ключь внутри словаря при помощи in ожно искать только ключи в словаре если искомый ключ есть то мы 
получим True если искомого ключа нет получим False также если попытаемся найти значение также получим Fale. Важно при 
помощи in можем найти только ключи'''

# a = dict(
#     name='Viktor',
#     age=29,
#     is_married=True,
#     pets_name=['Rex', 'Bob', 'Skub']
# )
# print('name' in a)


'''Метод позволяет вызвать кортеж кортежей получаем пары ключ значение всего словаря где каждый нулевой элемент будет ключом а каждое значение единицей'''

# items()
# a = dict(
#     name='Viktor',
#     age=29,
#     is_married=True,
#     pets_name=['Rex', 'Bob', 'Skub']
# )
# print(a.items())


'''Метод позволяет получить все значения из словаря'''

# values()
# a = dict(
#     name='Viktor',
#     age=29,
#     is_married=True,
#     pets_name=['Rex', 'Bob', 'Skub']
# )
# print(a.values())


'''Метод позволяет получить все ключи'''

# keys()
# a = dict(
#     name='Viktor',
#     age=29,
#     is_married=True,
#     pets_name=['Rex', 'Bob', 'Skub']
# )
# print(a.keys())


'''Метод отображает колличество ключей в словаре'''

# len()
# a = dict(
#     name='Viktor',
#     age=29,
#     is_married=True,
#     pets_name=['Rex', 'Bob', 'Skub']
# )
# print(len(a))


'''Метод чистит словарь'''

# clear()
# a = dict(
#     name='Viktor',
#     age=29,
#     is_married=True,
#     pets_name=['Rex', 'Bob', 'Skub']
# )
# print(a.clear())


'''Метод копирует словарь'''

# copy()
# a = dict(
#     name='Viktor',
#     age=29,
#     is_married=True,
#     pets_name=['Rex', 'Bob', 'Skub']
# )
# b = a.copy()
# print(b, a)




'''Метод используеться для множественного добавления/изменения словаря. Можно записать двумя способами'''

#update()
# a = {
#     'name': 'Viktor',
#     'age': 29,
#     'is_married': True,
#     'pets_name': ['Rex', 'Bob', 'Skub']
# }
# a.update({'test': 'newValue', 'test_2': 'newValue_2'})
# print(a)


#update()
# a = dict(
#     name='Viktor',
#     age=29,
#     is_married=True,
#     pets_name=['Rex', 'Bob', 'Skub']
# )
# a.update(test='newValue_3', test_2='newValue_3')
# print(a)
